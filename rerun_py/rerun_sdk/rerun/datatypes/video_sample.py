# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_types/definitions/rerun/datatypes/video.fbs".

# You can extend this class by creating a "VideoSampleExt" class in "video_sample_ext.py".

from __future__ import annotations

from typing import Any, Sequence, Union

import pyarrow as pa
from attrs import define, field

from .. import datatypes
from .._baseclasses import (
    BaseBatch,
    BaseExtensionType,
)

__all__ = ["VideoSample", "VideoSampleArrayLike", "VideoSampleBatch", "VideoSampleLike", "VideoSampleType"]


def _video_sample__timestamp__special_field_converter_override(x: datatypes.UInt64Like) -> datatypes.UInt64:
    if isinstance(x, datatypes.UInt64):
        return x
    else:
        return datatypes.UInt64(x)


def _video_sample__byte_offset__special_field_converter_override(x: datatypes.UInt32Like) -> datatypes.UInt32:
    if isinstance(x, datatypes.UInt32):
        return x
    else:
        return datatypes.UInt32(x)


def _video_sample__byte_length__special_field_converter_override(x: datatypes.UInt32Like) -> datatypes.UInt32:
    if isinstance(x, datatypes.UInt32):
        return x
    else:
        return datatypes.UInt32(x)


@define(init=False)
class VideoSample:
    """
    **Datatype**: A video sample.

    Similar to a frame of video, but decoding a full frame typically requires more than one sample.

    Samples can either be key frames or delta frames. Only key frames have enough data to decode a full frame,
    delta frames always require the context of a key frame and possibly also some number of preceding delta
    frames to decode a full frame.

    The type of a given sample is implicit in its position in the [`datatypes.VideoSegment`][rerun.datatypes.VideoSegment] it belongs to,
    where the first sample is always a key frame.
    """

    def __init__(
        self: Any, timestamp: datatypes.UInt64Like, byte_offset: datatypes.UInt32Like, byte_length: datatypes.UInt32Like
    ):
        """
        Create a new instance of the VideoSample datatype.

        Parameters
        ----------
        timestamp:
            Time at which this sample appears, in time units.
        byte_offset:
            Offset into video data.
        byte_length:
            Length of the sample starting at the sample's byte offset.

        """

        # You can define your own __init__ function as a member of VideoSampleExt in video_sample_ext.py
        self.__attrs_init__(timestamp=timestamp, byte_offset=byte_offset, byte_length=byte_length)

    timestamp: datatypes.UInt64 = field(converter=_video_sample__timestamp__special_field_converter_override)
    # Time at which this sample appears, in time units.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    byte_offset: datatypes.UInt32 = field(converter=_video_sample__byte_offset__special_field_converter_override)
    # Offset into video data.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    byte_length: datatypes.UInt32 = field(converter=_video_sample__byte_length__special_field_converter_override)
    # Length of the sample starting at the sample's byte offset.
    #
    # (Docstring intentionally commented out to hide this field from the docs)


VideoSampleLike = VideoSample
VideoSampleArrayLike = Union[
    VideoSample,
    Sequence[VideoSampleLike],
]


class VideoSampleType(BaseExtensionType):
    _TYPE_NAME: str = "rerun.datatypes.VideoSample"

    def __init__(self) -> None:
        pa.ExtensionType.__init__(
            self,
            pa.struct([
                pa.field("timestamp", pa.uint64(), nullable=False, metadata={}),
                pa.field("byte_offset", pa.uint32(), nullable=False, metadata={}),
                pa.field("byte_length", pa.uint32(), nullable=False, metadata={}),
            ]),
            self._TYPE_NAME,
        )


class VideoSampleBatch(BaseBatch[VideoSampleArrayLike]):
    _ARROW_TYPE = VideoSampleType()

    @staticmethod
    def _native_to_pa_array(data: VideoSampleArrayLike, data_type: pa.DataType) -> pa.Array:
        from rerun.datatypes import UInt32Batch, UInt64Batch

        if isinstance(data, VideoSample):
            data = [data]

        return pa.StructArray.from_arrays(
            [
                UInt64Batch([x.timestamp for x in data]).as_arrow_array().storage,  # type: ignore[misc, arg-type]
                UInt32Batch([x.byte_offset for x in data]).as_arrow_array().storage,  # type: ignore[misc, arg-type]
                UInt32Batch([x.byte_length for x in data]).as_arrow_array().storage,  # type: ignore[misc, arg-type]
            ],
            fields=list(data_type),
        )
